{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst getTreeWindowIntersection = (list, index, firstIDinWindow, lastIDinWindow) => {\n  const tree = list[index];\n  if (tree.id > lastIDinWindow) return 'after';\n  const nextTree = list[index + 1];\n\n  if (tree.id < firstIDinWindow) {\n    if (nextTree && nextTree.id > firstIDinWindow) {\n      return 'intersects';\n    }\n  } else if (tree.id <= lastIDinWindow) {\n    return 'intersects';\n  }\n\n  return 'before';\n};\n\nexport const getWindowedTreeNodeFilterer = (filteredList, firstIDinWindow, lastIDinWindow) => (node, index, list) => {\n  const intersection = getTreeWindowIntersection(list, index, firstIDinWindow, lastIDinWindow);\n  if (intersection === 'after') return false;\n\n  if (intersection === 'intersects') {\n    const treeItems = node.items;\n\n    if (treeItems) {\n      const filteredItems = [];\n      treeItems.every(getWindowedTreeNodeFilterer(filteredItems, firstIDinWindow, lastIDinWindow));\n\n      const treeWithFilteredItems = _objectSpread(_objectSpread({}, node), {}, {\n        items: filteredItems\n      });\n\n      filteredList.push(treeWithFilteredItems);\n    } else {\n      filteredList.push(node);\n    }\n  }\n\n  return true;\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,MAAMA,yBAAyB,GAAG,CAChCC,IADgC,EAEhCC,KAFgC,EAGhCC,eAHgC,EAIhCC,cAJgC,KAK7B;EACH,MAAMC,IAAI,GAAGJ,IAAI,CAACC,KAAD,CAAjB;EACA,IAAIG,IAAI,CAACC,EAALD,GAAUD,cAAd,EAA8B,OAAO,OAAP;EAE9B,MAAMG,QAAQ,GAAGN,IAAI,CAACC,KAAK,GAAG,CAAT,CAArB;;EACA,IAAIG,IAAI,CAACC,EAALD,GAAUF,eAAd,EAA+B;IAC7B,IAAII,QAAQ,IAAIA,QAAQ,CAACD,EAATC,GAAcJ,eAA9B,EAA+C;MAC7C,OAAO,YAAP;IACF;EACD,CAJD,MAIO,IAAIE,IAAI,CAACC,EAALD,IAAWD,cAAf,EAA+B;IACpC,OAAO,YAAP;EACF;;EACA,OAAO,QAAP;AACD,CAlBD;;AAoBA,OAAO,MAAMI,2BAA2B,GACtC,CACEC,YADF,EAEEN,eAFF,EAGEC,cAHF,KAKA,CACEM,IADF,EAEER,KAFF,EAGED,IAHF,KAIK;EACH,MAAMU,YAAY,GAAGX,yBAAyB,CAC5CC,IAD4C,EAE5CC,KAF4C,EAG5CC,eAH4C,EAI5CC,cAJ4C,CAA9C;EAOA,IAAIO,YAAY,KAAK,OAArB,EAA8B,OAAO,KAAP;;EAE9B,IAAIA,YAAY,KAAK,YAArB,EAAmC;IACjC,MAAMC,SAAS,GAAGF,IAAI,CAACG,KAAvB;;IACA,IAAID,SAAJ,EAAe;MAEb,MAAME,aAAwC,GAAG,EAAjD;MACAF,SAAS,CAACG,KAAVH,CACEJ,2BAA2B,CACzBM,aADyB,EAEzBX,eAFyB,EAGzBC,cAHyB,CAD7BQ;;MAOA,MAAMI,qBAAqB,mCAAQN,IAAR,GAAY,EAAZ,EAAY;QAAEG,KAAK,EAAEC;MAAT,CAAZ,CAA3B;;MACAL,YAAY,CAACQ,IAAbR,CAAkBO,qBAAlBP;IACD,CAZD,MAYO;MAELA,YAAY,CAACQ,IAAbR,CAAkBC,IAAlBD;IACF;EACF;;EAIA,OAAO,IAAP;AACD,CA3CI","names":["getTreeWindowIntersection","list","index","firstIDinWindow","lastIDinWindow","tree","id","nextTree","getWindowedTreeNodeFilterer","filteredList","node","intersection","treeItems","items","filteredItems","every","treeWithFilteredItems","push"],"sources":["/Users/elizabethrodricks/Downloads/express-react-starter-master/node_modules/@looker/components/src/Tree/utils/getWindowedTreeNodeFilterer.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport type { WindowedTreeNodeIDProps } from '../types'\n\nconst getTreeWindowIntersection = (\n  list: WindowedTreeNodeIDProps[],\n  index: number,\n  firstIDinWindow: number,\n  lastIDinWindow: number\n) => {\n  const tree = list[index]\n  if (tree.id > lastIDinWindow) return 'after'\n\n  const nextTree = list[index + 1]\n  if (tree.id < firstIDinWindow) {\n    if (nextTree && nextTree.id > firstIDinWindow) {\n      return 'intersects'\n    }\n  } else if (tree.id <= lastIDinWindow) {\n    return 'intersects'\n  }\n  return 'before'\n}\n\nexport const getWindowedTreeNodeFilterer =\n  (\n    filteredList: WindowedTreeNodeIDProps[],\n    firstIDinWindow: number,\n    lastIDinWindow: number\n  ) =>\n  (\n    node: WindowedTreeNodeIDProps,\n    index: number,\n    list: WindowedTreeNodeIDProps[]\n  ) => {\n    const intersection = getTreeWindowIntersection(\n      list,\n      index,\n      firstIDinWindow,\n      lastIDinWindow\n    )\n    // If the node is after the window, stop looping\n    if (intersection === 'after') return false\n\n    if (intersection === 'intersects') {\n      const treeItems = node.items\n      if (treeItems) {\n        // Recursively filter the tree's items\n        const filteredItems: WindowedTreeNodeIDProps[] = []\n        treeItems.every(\n          getWindowedTreeNodeFilterer(\n            filteredItems,\n            firstIDinWindow,\n            lastIDinWindow\n          )\n        )\n        const treeWithFilteredItems = { ...node, items: filteredItems }\n        filteredList.push(treeWithFilteredItems)\n      } else {\n        // This is an item (not a tree) within the window\n        filteredList.push(node)\n      }\n    }\n    // Return true to keep looping for either 'before' or 'intersects'\n    // 'before': we need to keep checking to find the first intersecting tree\n    // 'intersects': the next tree may also intersect the window\n    return true\n  }\n"]},"metadata":{},"sourceType":"module"}