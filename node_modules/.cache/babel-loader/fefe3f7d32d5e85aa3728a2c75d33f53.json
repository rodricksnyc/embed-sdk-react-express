{"ast":null,"code":"export const getTabStops = function (ref) {\n  let selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'a,button:not(:disabled),[tabindex=\"0\"],[tabindex=\"-1\"]:not(:disabled)';\n  return Array.from(ref.querySelectorAll(selector));\n};\nexport const getFallbackElement = (direction, containerElement, tabStops) => {\n  let fallback;\n\n  if (direction === 1) {\n    const firstVisibleChild = tabStops.find(childElement => {\n      return childElement.offsetTop >= containerElement.scrollTop;\n      return false;\n    });\n    if (firstVisibleChild) fallback = firstVisibleChild;else fallback = tabStops[0];\n  } else {\n    fallback = tabStops[tabStops.length - 1];\n  }\n\n  return fallback;\n};\nexport const getNextFocus = (direction, element) => {\n  const tabStops = getTabStops(element);\n  const focusedElement = document.activeElement;\n\n  if (tabStops.length > 0 && focusedElement instanceof HTMLElement) {\n    if (tabStops.includes(focusedElement)) {\n      const next = tabStops.findIndex(el => el === document.activeElement) + direction;\n\n      if (next === tabStops.length || !tabStops[next]) {\n        return getFallbackElement(direction, element, tabStops);\n      }\n\n      return tabStops[next];\n    }\n\n    return getFallbackElement(direction, element, tabStops);\n  }\n\n  return null;\n};","map":{"version":3,"mappings":"AAKA,OAAO,MAAMA,WAAW,GAAG,UACzBC,GADyB;EAAA,IAEzBC,QAFyB,uEAEd,uEAFc;EAAA,OAGPC,KAAK,CAACC,IAAND,CAAWF,GAAG,CAACI,gBAAJJ,CAAqBC,QAArBD,CAAXE,CAHO;AAAA,CAApB;AAMP,OAAO,MAAMG,kBAAkB,GAAG,CAChCC,SADgC,EAEhCC,gBAFgC,EAGhCC,QAHgC,KAI7B;EACH,IAAIC,QAAJ;;EAEA,IAAIH,SAAS,KAAK,CAAlB,EAAqB;IACnB,MAAMI,iBAAiB,GAAGF,QAAQ,CAACG,IAATH,CAAcI,YAAY,IAAI;MACtD,OAAOA,YAAY,CAACC,SAAbD,IAA0BL,gBAAgB,CAACO,SAAlD;MACA,OAAO,KAAP;IACD,CAHyBN,CAA1B;IAKA,IAAIE,iBAAJ,EAAuBD,QAAQ,GAAGC,iBAAXD,CAAvB,KACKA,QAAQ,GAAGD,QAAQ,CAAC,CAAD,CAAnBC;EACN,CARD,MAQO;IACLA,QAAQ,GAAGD,QAAQ,CAACA,QAAQ,CAACO,MAATP,GAAkB,CAAnB,CAAnBC;EACF;;EAEA,OAAOA,QAAP;AACD,CApBM;AA2BP,OAAO,MAAMO,YAAY,GAAG,CAACV,SAAD,EAAoBW,OAApB,KAA6C;EACvE,MAAMT,QAAQ,GAAGT,WAAW,CAACkB,OAAD,CAA5B;EAEA,MAAMC,cAAc,GAAGC,QAAQ,CAACC,aAAhC;;EAEA,IAAIZ,QAAQ,CAACO,MAATP,GAAkB,CAAlBA,IAAuBU,cAAc,YAAYG,WAArD,EAAkE;IAChE,IAAIb,QAAQ,CAACc,QAATd,CAAkBU,cAAlBV,CAAJ,EAAuC;MACrC,MAAMe,IAAI,GACRf,QAAQ,CAACgB,SAAThB,CAAmBiB,EAAE,IAAIA,EAAE,KAAKN,QAAQ,CAACC,aAAzCZ,IAA0DF,SAD5D;;MAGA,IAAIiB,IAAI,KAAKf,QAAQ,CAACO,MAAlBQ,IAA4B,CAACf,QAAQ,CAACe,IAAD,CAAzC,EAAiD;QAE/C,OAAOlB,kBAAkB,CAACC,SAAD,EAAYW,OAAZ,EAAqBT,QAArB,CAAzB;MACF;;MAEA,OAAOA,QAAQ,CAACe,IAAD,CAAf;IACF;;IACA,OAAOlB,kBAAkB,CAACC,SAAD,EAAYW,OAAZ,EAAqBT,QAArB,CAAzB;EACF;;EACA,OAAO,IAAP;AACD,CApBM","names":["getTabStops","ref","selector","Array","from","querySelectorAll","getFallbackElement","direction","containerElement","tabStops","fallback","firstVisibleChild","find","childElement","offsetTop","scrollTop","length","getNextFocus","element","focusedElement","document","activeElement","HTMLElement","includes","next","findIndex","el"],"sources":["/Users/elizabethrodricks/Downloads/express-react-starter-master/node_modules/@looker/components/src/utils/getNextFocus.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nexport const getTabStops = (\n  ref: HTMLElement,\n  selector = 'a,button:not(:disabled),[tabindex=\"0\"],[tabindex=\"-1\"]:not(:disabled)'\n): HTMLElement[] => Array.from(ref.querySelectorAll(selector))\n\n// Returns a fallback element (called when the element with focus has been removed from the DOM)\nexport const getFallbackElement = (\n  direction: 1 | -1,\n  containerElement: HTMLElement,\n  tabStops: HTMLElement[]\n) => {\n  let fallback: HTMLElement\n\n  if (direction === 1) {\n    const firstVisibleChild = tabStops.find(childElement => {\n      return childElement.offsetTop >= containerElement.scrollTop\n      return false\n    })\n\n    if (firstVisibleChild) fallback = firstVisibleChild\n    else fallback = tabStops[0]\n  } else {\n    fallback = tabStops[tabStops.length - 1]\n  }\n\n  return fallback\n}\n\n/**\n * Returns the next focusable inside an element in a given direction\n * @param direction 1 for forward -1 for reverse\n * @param element the container element\n */\nexport const getNextFocus = (direction: 1 | -1, element: HTMLElement) => {\n  const tabStops = getTabStops(element)\n\n  const focusedElement = document.activeElement\n\n  if (tabStops.length > 0 && focusedElement instanceof HTMLElement) {\n    if (tabStops.includes(focusedElement)) {\n      const next =\n        tabStops.findIndex(el => el === document.activeElement) + direction\n\n      if (next === tabStops.length || !tabStops[next]) {\n        // Reached the end of tab stops for this direction\n        return getFallbackElement(direction, element, tabStops)\n      }\n\n      return tabStops[next]\n    }\n    return getFallbackElement(direction, element, tabStops)\n  }\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}