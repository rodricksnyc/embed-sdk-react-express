{"ast":null,"code":"export const stringComparator = (stringA, stringB) => {\n  const upperCasedStringA = stringA.toUpperCase();\n  const upperCasedStringB = stringB.toUpperCase();\n  if (upperCasedStringA < upperCasedStringB) return -1;\n  if (upperCasedStringA > upperCasedStringB) return 1;\n  return 0;\n};\nexport const dateComparator = (dateA, dateB) => {\n  if (dateA < dateB) return -1;\n  if (dateA > dateB) return 1;\n  return 0;\n};\nexport const doDataTableSort = (data, columns, id, sortDirection) => {\n  const sortedData = [...data];\n  const updatedColumns = [...columns];\n  const targetColumn = updatedColumns.find(column => column.id === id);\n  columns.forEach(column => delete column.sortDirection);\n\n  if (targetColumn) {\n    if (targetColumn.type === 'number') {\n      if (sortDirection === 'desc') {\n        sortedData.sort((a, b) => b[id] - a[id]);\n      } else {\n        sortedData.sort((a, b) => a[id] - b[id]);\n      }\n    } else if (targetColumn.type === 'date') {\n      if (sortDirection === 'desc') {\n        sortedData.sort((a, b) => dateComparator(b[id], a[id]));\n      } else {\n        sortedData.sort((a, b) => dateComparator(a[id], b[id]));\n      }\n    } else {\n      if (sortDirection === 'desc') {\n        sortedData.sort((a, b) => stringComparator(b[id], a[id]));\n      } else {\n        sortedData.sort((a, b) => stringComparator(a[id], b[id]));\n      }\n    }\n\n    targetColumn.sortDirection = sortDirection;\n  }\n\n  return {\n    columns: updatedColumns,\n    data: sortedData\n  };\n};","map":{"version":3,"mappings":"AAOA,OAAO,MAAMA,gBAAgB,GAAG,CAACC,OAAD,EAAkBC,OAAlB,KAAsC;EACpE,MAAMC,iBAAiB,GAAGF,OAAO,CAACG,WAARH,EAA1B;EACA,MAAMI,iBAAiB,GAAGH,OAAO,CAACE,WAARF,EAA1B;EAEA,IAAIC,iBAAiB,GAAGE,iBAAxB,EAA2C,OAAO,CAAC,CAAR;EAC3C,IAAIF,iBAAiB,GAAGE,iBAAxB,EAA2C,OAAO,CAAP;EAC3C,OAAO,CAAP;AACD,CAPM;AASP,OAAO,MAAMC,cAAc,GAAG,CAACC,KAAD,EAAcC,KAAd,KAA8B;EAC1D,IAAID,KAAK,GAAGC,KAAZ,EAAmB,OAAO,CAAC,CAAR;EACnB,IAAID,KAAK,GAAGC,KAAZ,EAAmB,OAAO,CAAP;EACnB,OAAO,CAAP;AACD,CAJM;AAoBP,OAAO,MAAMC,eAAe,GAAG,CAC7BC,IAD6B,EAE7BC,OAF6B,EAG7BC,EAH6B,EAI7BC,aAJ6B,KAK1B;EAEH,MAAMC,UAAyC,GAAG,CAAC,GAAGJ,IAAJ,CAAlD;EACA,MAAMK,cAAc,GAAG,CAAC,GAAGJ,OAAJ,CAAvB;EACA,MAAMK,YAAY,GAAGD,cAAc,CAACE,IAAfF,CAAoBG,MAAM,IAAIA,MAAM,CAACN,EAAPM,KAAcN,EAA5CG,CAArB;EAIAJ,OAAO,CAACQ,OAARR,CAAgBO,MAAM,IAAI,OAAOA,MAAM,CAACL,aAAxCF;;EACA,IAAIK,YAAJ,EAAkB;IAChB,IAAIA,YAAY,CAACI,IAAbJ,KAAsB,QAA1B,EAAoC;MAClC,IAAIH,aAAa,KAAK,MAAtB,EAA8B;QAC5BC,UAAU,CAACO,IAAXP,CAAgB,CAACQ,CAAD,EAAIC,CAAJ,KAAUA,CAAC,CAACX,EAAD,CAADW,GAAQD,CAAC,CAACV,EAAD,CAAnCE;MACD,CAFD,MAEO;QACLA,UAAU,CAACO,IAAXP,CAAgB,CAACQ,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACV,EAAD,CAADU,GAAQC,CAAC,CAACX,EAAD,CAAnCE;MACF;IACD,CAND,MAMO,IAAIE,YAAY,CAACI,IAAbJ,KAAsB,MAA1B,EAAkC;MACvC,IAAIH,aAAa,KAAK,MAAtB,EAA8B;QAC5BC,UAAU,CAACO,IAAXP,CAAgB,CAACQ,CAAD,EAAIC,CAAJ,KAAUjB,cAAc,CAACiB,CAAC,CAACX,EAAD,CAAF,EAAQU,CAAC,CAACV,EAAD,CAAT,CAAxCE;MACD,CAFD,MAEO;QACLA,UAAU,CAACO,IAAXP,CAAgB,CAACQ,CAAD,EAAIC,CAAJ,KAAUjB,cAAc,CAACgB,CAAC,CAACV,EAAD,CAAF,EAAQW,CAAC,CAACX,EAAD,CAAT,CAAxCE;MACF;IACD,CANM,MAMA;MACL,IAAID,aAAa,KAAK,MAAtB,EAA8B;QAC5BC,UAAU,CAACO,IAAXP,CAAgB,CAACQ,CAAD,EAAIC,CAAJ,KAAUvB,gBAAgB,CAACuB,CAAC,CAACX,EAAD,CAAF,EAAQU,CAAC,CAACV,EAAD,CAAT,CAA1CE;MACD,CAFD,MAEO;QACLA,UAAU,CAACO,IAAXP,CAAgB,CAACQ,CAAD,EAAIC,CAAJ,KAAUvB,gBAAgB,CAACsB,CAAC,CAACV,EAAD,CAAF,EAAQW,CAAC,CAACX,EAAD,CAAT,CAA1CE;MACF;IACF;;IACAE,YAAY,CAACH,aAAbG,GAA6BH,aAA7BG;EACF;;EAEA,OAAO;IACLL,OAAO,EAAEI,cADJ;IAELL,IAAI,EAAEI;EAFD,CAAP;AAID,CAzCM","names":["stringComparator","stringA","stringB","upperCasedStringA","toUpperCase","upperCasedStringB","dateComparator","dateA","dateB","doDataTableSort","data","columns","id","sortDirection","sortedData","updatedColumns","targetColumn","find","column","forEach","type","sort","a","b"],"sources":["/Users/elizabethrodricks/Downloads/express-react-starter-master/node_modules/@looker/components/src/DataTable/utils/sort_utils.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport type { DataTableColumns } from '../Column'\n\nexport const stringComparator = (stringA: string, stringB: string) => {\n  const upperCasedStringA = stringA.toUpperCase()\n  const upperCasedStringB = stringB.toUpperCase()\n\n  if (upperCasedStringA < upperCasedStringB) return -1\n  if (upperCasedStringA > upperCasedStringB) return 1\n  return 0\n}\n\nexport const dateComparator = (dateA: Date, dateB: Date) => {\n  if (dateA < dateB) return -1\n  if (dateA > dateB) return 1\n  return 0\n}\n\n// Guy Ellis 2022-09-23 - The data table sorting is based on a DataTableColumnType which is either undefined or\n// one of \"string\" | \"number\" | \"date\". The comparator in the sort method is based on the data type.\n// However, there is no strong typing between the data and the \"type\". In other words, even if the\n// type says \"number\" we have no TypeScript verifiable way to ensure that the associated data is a number.\n// Of course, we can do type narrowing at each instance usage but that would then risk unanticipated runtime\n// errors if there were a non-match that still currently provided the user with some functionality even though\n// that might not be perfectly correct.\n// At some point in the future we might want to split doDataTableSort() into 3 methods that each operate on a\n// given data type or we might want to pass the comparator() method as a parameter. This would allow up to\n// remove the no-explicit-any disable. b/201417582\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DataTableDatum = Record<string, any>\nexport type DataTableData = DataTableDatum[]\n\nexport const doDataTableSort = <T>(\n  data: T[],\n  columns: DataTableColumns,\n  id: string,\n  sortDirection: 'asc' | 'desc'\n) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const sortedData: Array<{ [key: string]: any }> = [...data]\n  const updatedColumns = [...columns]\n  const targetColumn = updatedColumns.find(column => column.id === id)\n\n  // The default sort behavior only allows for one column to appear sorted at a time\n  // Using delete operator to clean out all sortDirection properties in our columns array\n  columns.forEach(column => delete column.sortDirection)\n  if (targetColumn) {\n    if (targetColumn.type === 'number') {\n      if (sortDirection === 'desc') {\n        sortedData.sort((a, b) => b[id] - a[id])\n      } else {\n        sortedData.sort((a, b) => a[id] - b[id])\n      }\n    } else if (targetColumn.type === 'date') {\n      if (sortDirection === 'desc') {\n        sortedData.sort((a, b) => dateComparator(b[id], a[id]))\n      } else {\n        sortedData.sort((a, b) => dateComparator(a[id], b[id]))\n      }\n    } else {\n      if (sortDirection === 'desc') {\n        sortedData.sort((a, b) => stringComparator(b[id], a[id]))\n      } else {\n        sortedData.sort((a, b) => stringComparator(a[id], b[id]))\n      }\n    }\n    targetColumn.sortDirection = sortDirection\n  }\n\n  return {\n    columns: updatedColumns,\n    data: sortedData as T[],\n  }\n}\n"]},"metadata":{},"sourceType":"module"}