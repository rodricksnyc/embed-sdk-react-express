{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { getComboboxText } from '../../Combobox';\nexport function getMatchingOption(value, options) {\n  return options === null || options === void 0 ? void 0 : options.find(option => option.value === value);\n}\nexport function getOption(value, options) {\n  const matchingOption = getMatchingOption(value, options);\n  const label = matchingOption === null || matchingOption === void 0 ? void 0 : matchingOption.label;\n  const labelProps = label ? {\n    label\n  } : {};\n  return value !== undefined ? _objectSpread(_objectSpread({}, labelProps), {}, {\n    value\n  }) : undefined;\n}\nexport function getOptions(values, options) {\n  if (!values) return undefined;\n  return values.map(value => ({\n    label: getComboboxText(value, options),\n    value\n  }));\n}\nexport function compareOption(option, value) {\n  return getComboboxText(option).toLowerCase() === value.toLowerCase();\n}\nexport function getFirstOption(options) {\n  const optionAsGroup = options[0];\n  if (optionAsGroup && optionAsGroup.options) return optionAsGroup.options[0];\n  return options[0];\n}\nexport function notInOptions(currentOptions, options, inputValue) {\n  if (!inputValue) return false;\n\n  if (currentOptions.find(option => compareOption(option, inputValue))) {\n    return false;\n  }\n\n  if (!options) return true;\n  return options.find(option => compareOption(option, inputValue)) === undefined;\n}\n\nconst checkForIcon = option => option.icon !== undefined;\n\nexport const optionsHaveIcons = options => {\n  if (!options || options.length === 0) return false;\n  return options.some(option => checkForIcon(option));\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,SAASA,eAAT,QAAgC,gBAAhC;AAOA,OAAO,SAASC,iBAAT,CACLC,KADK,EAELC,OAFK,EAGL;EACA,OAAOA,OAAO,SAAPA,WAAO,WAAPA,GAAO,MAAPA,UAAO,CAAEC,IAATD,CAAcE,MAAM,IAAIA,MAAM,CAACH,KAAPG,KAAiBH,KAAzCC,CAAP;AACF;AAEA,OAAO,SAASG,SAAT,CAAmBJ,KAAnB,EAAmCC,OAAnC,EAAmE;EACxE,MAAMI,cAAc,GAAGN,iBAAiB,CAACC,KAAD,EAAQC,OAAR,CAAxC;EACA,MAAMK,KAAK,GAAGD,cAAc,SAAdA,kBAAc,WAAdA,GAAc,MAAdA,iBAAc,CAAEC,KAA9B;EAGA,MAAMC,UAAU,GAAGD,KAAK,GAAG;IAAEA;EAAF,CAAH,GAAe,EAAvC;EACA,OAAON,KAAK,KAAKQ,SAAVR,GAAmBS,gCAAQF,UAAR,GAAkB,EAAlB,EAAkB;IAAEP;EAAF,CAAlB,CAAnBA,GAAiDQ,SAAxD;AACF;AAEA,OAAO,SAASE,UAAT,CACLC,MADK,EAELV,OAFK,EAG6B;EAClC,IAAI,CAACU,MAAL,EAAa,OAAOH,SAAP;EACb,OAAOG,MAAM,CAACC,GAAPD,CAAWX,KAAK,KAAK;IAC1BM,KAAK,EAAER,eAAe,CAACE,KAAD,EAAQC,OAAR,CADI;IAE1BD;EAF0B,CAAL,CAAhBW,CAAP;AAIF;AAEA,OAAO,SAASE,aAAT,CAAuBV,MAAvB,EAAkDH,KAAlD,EAAiE;EACtE,OAAOF,eAAe,CAACK,MAAD,CAAfL,CAAwBgB,WAAxBhB,OAA0CE,KAAK,CAACc,WAANd,EAAjD;AACF;AAEA,OAAO,SAASe,cAAT,CACLd,OADK,EAEe;EACpB,MAAMe,aAAa,GAAGf,OAAO,CAAC,CAAD,CAA7B;EACA,IAAIe,aAAa,IAAIA,aAAa,CAACf,OAAnC,EAA4C,OAAOe,aAAa,CAACf,OAAde,CAAsB,CAAtBA,CAAP;EAC5C,OAAOf,OAAO,CAAC,CAAD,CAAd;AACF;AAGA,OAAO,SAASgB,YAAT,CACLC,cADK,EAELjB,OAFK,EAGLkB,UAHK,EAIL;EACA,IAAI,CAACA,UAAL,EAAiB,OAAO,KAAP;;EACjB,IAAID,cAAc,CAAChB,IAAfgB,CAAoBf,MAAM,IAAIU,aAAa,CAACV,MAAD,EAASgB,UAAT,CAA3CD,CAAJ,EAAsE;IACpE,OAAO,KAAP;EACF;;EACA,IAAI,CAACjB,OAAL,EAAc,OAAO,IAAP;EACd,OAAOA,OAAO,CAACC,IAARD,CAAaE,MAAM,IAAIU,aAAa,CAACV,MAAD,EAASgB,UAAT,CAApClB,MAA8DO,SAArE;AACF;;AAEA,MAAMY,YAAY,GAAIjB,MAA0B,IAAKA,MAAM,CAACkB,IAAPlB,KAAgBK,SAArE;;AAEA,OAAO,MAAMc,gBAAgB,GAAIrB,OAA8B,IAAK;EAClE,IAAI,CAACA,OAAD,IAAYA,OAAO,CAACsB,MAARtB,KAAmB,CAAnC,EAAsC,OAAO,KAAP;EACtC,OAAOA,OAAO,CAACuB,IAARvB,CAAaE,MAAM,IAAIiB,YAAY,CAACjB,MAAD,CAAnCF,CAAP;AACD,CAHM","names":["getComboboxText","getMatchingOption","value","options","find","option","getOption","matchingOption","label","labelProps","undefined","_objectSpread","getOptions","values","map","compareOption","toLowerCase","getFirstOption","optionAsGroup","notInOptions","currentOptions","inputValue","checkForIcon","icon","optionsHaveIcons","length","some"],"sources":["/Users/elizabethrodricks/Downloads/express-react-starter-master/node_modules/@looker/components/src/Form/Inputs/Select/utils/options.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport type { ComboboxOptionObject } from '../../Combobox'\nimport { getComboboxText } from '../../Combobox'\nimport type {\n  SelectOptionGroupProps,\n  SelectOptionObject,\n  SelectOptionProps,\n} from '../types'\n\nexport function getMatchingOption(\n  value?: string,\n  options?: SelectOptionObject[]\n) {\n  return options?.find(option => option.value === value)\n}\n\nexport function getOption(value?: string, options?: SelectOptionObject[]) {\n  const matchingOption = getMatchingOption(value, options)\n  const label = matchingOption?.label\n  // If this is a filterable Select and the current option has been filtered out\n  // leave label out, so that the matching against the option saved in ComboboxContext won't fail\n  const labelProps = label ? { label } : {}\n  return value !== undefined ? { ...labelProps, value } : undefined\n}\n\nexport function getOptions(\n  values?: string[],\n  options?: SelectOptionObject[]\n): SelectOptionObject[] | undefined {\n  if (!values) return undefined\n  return values.map(value => ({\n    label: getComboboxText(value, options),\n    value,\n  }))\n}\n\nexport function compareOption(option: { value: string }, value: string) {\n  return getComboboxText(option).toLowerCase() === value.toLowerCase()\n}\n\nexport function getFirstOption(\n  options: SelectOptionProps[]\n): SelectOptionObject {\n  const optionAsGroup = options[0] as SelectOptionGroupProps\n  if (optionAsGroup && optionAsGroup.options) return optionAsGroup.options[0]\n  return options[0] as SelectOptionObject\n}\n\n// Is a value contained the specified options (logic to show the on-the-fly \"Create\" option)\nexport function notInOptions(\n  currentOptions: ComboboxOptionObject[],\n  options?: SelectOptionObject[],\n  inputValue?: string\n) {\n  if (!inputValue) return false\n  if (currentOptions.find(option => compareOption(option, inputValue))) {\n    return false\n  }\n  if (!options) return true\n  return options.find(option => compareOption(option, inputValue)) === undefined\n}\n\nconst checkForIcon = (option: SelectOptionObject) => option.icon !== undefined\n\nexport const optionsHaveIcons = (options?: SelectOptionObject[]) => {\n  if (!options || options.length === 0) return false\n  return options.some(option => checkForIcon(option))\n}\n"]},"metadata":{},"sourceType":"module"}